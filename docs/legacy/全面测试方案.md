# Twitter 自动发布系统：全面测试方案

基于项目的实际架构和功能实现，本文档提供了一套完整的、分层的、可执行的测试方案。该方案涵盖单元测试、集成测试和端到端测试，确保系统的质量、功能正确性和长期可维护性。

## 项目架构概览

当前项目采用模块化设计，主要包括：
- **API层** (`api/`): FastAPI应用，包含认证、仪表板、任务和项目管理路由
- **核心业务层** (`app/core/`): 内容生成器、发布器、项目管理器、任务调度器
- **数据库层** (`app/database/`): SQLAlchemy模型、仓库模式、数据库管理
- **工具层** (`app/utils/`): 配置管理、日志、性能监控、重试机制
- **前端** (`frontend/`): 简单的Web界面
- **脚本** (`scripts/`): 启动脚本和工具

---

#### **一、 测试核心原则与策略**

1.  **测试独立性**:
    *   **独立测试模块**: 所有测试代码将放置在一个独立的 `tests/` 目录下，与 `app/` 源代码完全分离。
    *   **独立测试数据库**: 测试运行时会自动创建一个独立的、内存中的 SQLite 数据库（或一个临时的测试文件），绝不使用生产数据库。每次测试运行开始时创建，结束后销毁，确保测试之间互不干扰。
    *   **独立测试配置**: 测试将加载一套独立的测试配置文件 (`tests/config.test.yaml`)，覆盖主配置，以使用测试专用的参数。

2.  **分层测试 (Testing Pyramid)**:
    *   **单元测试 (Unit Tests)**: 占最大比例。专注于测试单个函数或类的最小逻辑单元，速度快，隔离性好。使用 Mock（模拟）对象来替代外部依赖（如数据库、API）。
    *   **集成测试 (Integration Tests)**: 测试多个组件协同工作的正确性。例如，测试“内容生成器”和“任务创建逻辑”能否正确地将 JSON 解析并存入真实的（测试）数据库。
    *   **端到端测试 (E2E Tests)**: 占最小比例，但至关重要。模拟真实的用户操作流程，从调用 CLI 命令开始，到检查数据库状态，甚至（在严格控制下）与真实的外部 API 交互，验证整个系统的完整流程。

3.  **真实性与模拟的平衡**:
    *   **尽可能真实**: 对于系统内部逻辑，如数据库交互、文件解析、业务规则计算，必须使用真实的（测试）数据和配置进行验证。
    *   **明智地模拟**: 对于外部依赖，特别是那些有成本、有速率限制或不稳定的服务（Twitter API, Gemini API），在单元和集成测试中必须使用 Mock。只在专门的、标记清晰的 E2E 测试中才连接真实服务。

4.  **测试工具栈**:
    *   **测试框架**: **`pytest`** - 功能强大，支持 Fixtures、参数化、插件，是 Python 测试的事实标准。
    *   **模拟库**: **`unittest.mock`** (Python 内置) 或 **`pytest-mock`** - 用于创建 Mock 对象。
    *   **数据库测试**: SQLAlchemy + `pytest` Fixtures，用于管理测试数据库的生命周期。
    *   **CLI 测试**: `pytest` + `click.testing.CliRunner` - 用于在测试中调用和断言命令行应用的行为。
    *   **覆盖率工具**: **`pytest-cov`** - 用于衡量测试对代码的覆盖程度。

#### **二、 测试环境搭建**

1.  **测试文件结构**:
    ```
    twitter-trend/
    ├── app/                     # 源代码
    ├── api/                     # API源代码
    ├── tests/                   # 测试目录
    │   ├── __init__.py
    │   ├── conftest.py          # 全局测试配置和 Fixtures
    │   ├── test_data/           # 测试数据
    │   │   ├── projects/
    │   │   │   └── test_project/
    │   │   │       ├── output_video_music/
    │   │   │       │   ├── sample_video_01.mp4
    │   │   │       │   └── sample_video_02.mp4
    │   │   │       └── uploader_json/
    │   │   │           ├── en_prompt_results_batch.json
    │   │   │           └── cn_prompt_results_batch.json
    │   │   ├── config/
    │   │   │   ├── test_config.yaml
    │   │   │   └── test.env
    │   │   └── fixtures/
    │   │       ├── sample_metadata.json
    │   │       └── mock_responses.json
    │   ├── unit/                # 单元测试
    │   │   ├── core/
    │   │   │   ├── test_content_generator.py
    │   │   │   ├── test_publisher.py
    │   │   │   ├── test_project_manager.py
    │   │   │   └── test_task_scheduler.py
    │   │   ├── database/
    │   │   │   ├── test_models.py
    │   │   │   └── test_repository.py
    │   │   ├── utils/
    │   │   │   ├── test_config.py
    │   │   │   ├── test_logger.py
    │   │   │   └── test_file_handler.py
    │   │   └── api/
    │   │       ├── test_dependencies.py
    │   │       ├── test_middleware.py
    │   │       └── routers/
    │   │           ├── test_auth.py
    │   │           ├── test_dashboard.py
    │   │           ├── test_projects.py
    │   │           └── test_tasks.py
    │   ├── integration/         # 集成测试
    │   │   ├── test_api_integration.py
    │   │   ├── test_database_operations.py
    │   │   ├── test_content_pipeline.py
    │   │   └── test_scheduler_integration.py
    │   └── e2e/                 # 端到端测试
    │       ├── test_cli_workflows.py
    │       ├── test_api_workflows.py
    │       └── test_full_publishing_flow.py
    │
    ├── pytest.ini               # pytest 配置文件
    ├── requirements-test.txt    # 测试专用依赖
    └── ...
    ```

2.  **`pytest.ini` 配置**:
    ```ini
    [pytest]
    minversion = 6.0
    testpaths = tests
    addopts = -ra -q --cov=app --cov-report=term-missing
    markers = 
        e2e: marks tests as end-to-end (heavy, may involve real APIs)
        slow: marks tests as slow running
    ```

3.  **核心 Fixture (`tests/conftest.py`)**:
    ```python
    import pytest
    import os
    import tempfile
    import shutil
    from pathlib import Path
    from sqlalchemy import create_engine
    from sqlalchemy.orm import sessionmaker
    from fastapi.testclient import TestClient
    from click.testing import CliRunner
    
    from app.database.models import Base, User, Project
    from app.database.repository import UserRepository
    from app.utils.config import ConfigManager
    from api.main import app
    from api.dependencies import get_db, get_config

    @pytest.fixture(scope="session")
    def test_db_engine():
        """创建测试数据库引擎"""
        return create_engine("sqlite:///:memory:", echo=False)

    @pytest.fixture(scope="function")
    def db_session(test_db_engine):
        """为每个测试函数创建独立的数据库会话"""
        connection = test_db_engine.connect()
        transaction = connection.begin()
        Base.metadata.create_all(connection)
        Session = sessionmaker(bind=connection)
        session = Session()
        
        # 创建测试用户
        user_repo = UserRepository(session)
        test_user = user_repo.create({
            'username': 'test_user',
            'role': 'admin'
        })
        session.commit()
        
        yield session
        
        session.close()
        transaction.rollback()
        connection.close()

    @pytest.fixture
    def test_config():
        """测试配置"""
        config_data = {
            'database': {'url': 'sqlite:///:memory:'},
            'twitter': {
                'api_key': 'test_key',
                'api_secret': 'test_secret',
                'access_token': 'test_token',
                'access_token_secret': 'test_token_secret'
            },
            'gemini': {'api_key': 'test_gemini_key'},
            'scheduler': {
                'interval_minutes_min': 1,
                'interval_minutes_max': 2,
                'max_retries': 3
            },
            'logging': {'level': 'DEBUG'}
        }
        return ConfigManager(config_data=config_data)

    @pytest.fixture
    def test_client(db_session, test_config):
        """FastAPI测试客户端"""
        def override_get_db():
            yield db_session
        
        def override_get_config():
            return test_config
            
        app.dependency_overrides[get_db] = override_get_db
        app.dependency_overrides[get_config] = override_get_config
        
        with TestClient(app) as client:
            yield client
            
        app.dependency_overrides.clear()

    @pytest.fixture
    def cli_runner():
        """CLI测试运行器"""
        return CliRunner()

    @pytest.fixture
    def temp_project_dir():
        """临时项目目录"""
        temp_dir = tempfile.mkdtemp()
        project_dir = Path(temp_dir) / "test_project"
        project_dir.mkdir()
        
        # 创建测试目录结构
        (project_dir / "output_video_music").mkdir()
        (project_dir / "uploader_json").mkdir()
        
        yield str(project_dir)
        
        shutil.rmtree(temp_dir)

    @pytest.fixture
    def mock_tweepy(mocker):
        """模拟 tweepy 库"""
        mock_client = mocker.MagicMock()
        mock_api = mocker.MagicMock()
        
        # 模拟成功的API响应
        mock_client.create_tweet.return_value.data = {'id': '1234567890'}
        mock_api.media_upload.return_value.media_id_string = 'media_123'
        mock_api.verify_credentials.return_value.screen_name = 'test_user'
        
        mocker.patch('app.core.publisher.tweepy.Client', return_value=mock_client)
        mocker.patch('app.core.publisher.tweepy.API', return_value=mock_api)
        mocker.patch('app.core.publisher.tweepy.OAuth1UserHandler')
        
        return {'client': mock_client, 'api': mock_api}

    @pytest.fixture
    def mock_gemini(mocker):
        """模拟 google-generativeai 库"""
        mock_model = mocker.MagicMock()
        mock_model.generate_content.return_value.text = "Enhanced tweet content with AI"
        
        mocker.patch('app.core.content_generator.genai.configure')
        mocker.patch('app.core.content_generator.genai.GenerativeModel', return_value=mock_model)
        mocker.patch('app.core.content_generator.GEMINI_AVAILABLE', True)
        
        return mock_model

    @pytest.fixture
    def sample_metadata():
        """示例元数据"""
        return {
            "sample_video_01.mp4": {
                "title": "Test Video Title",
                "description": "This is a test video description for testing purposes.",
                "hashtags": ["#test", "#video", "#automation"],
                "keywords": ["test", "video", "automation"]
            }
        }

    @pytest.fixture
    def api_headers():
        """API请求头"""
        return {"X-API-Key": "test-api-key"}
    ```

#### **三、 详细测试方案**

**A. 单元测试 (Unit Tests)**

*   **目标**: 验证最小代码单元的逻辑正确性，完全隔离外部依赖。
*   **位置**: `tests/unit/`

### 1. 核心业务逻辑测试 (`tests/unit/core/`)

**`test_content_generator.py`**:
```python
def test_generate_tweet_from_json_directly(sample_metadata):
    """测试直接从JSON生成推文"""
    generator = ContentGenerator(use_ai=False)
    
    # 创建临时元数据文件
    with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
        json.dump(sample_metadata, f)
        metadata_path = f.name
    
    content, duration = generator.generate_tweet(
        metadata_path, "sample_video_01.mp4", "en"
    )
    
    assert "Test Video Title" in content
    assert "#test" in content
    assert len(content) <= 280
    assert duration > 0
    
    os.unlink(metadata_path)

def test_generate_tweet_with_ai(mock_gemini, sample_metadata):
    """测试AI增强推文生成"""
    generator = ContentGenerator(use_ai=True, gemini_api_key="test_key")
    
    with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
        json.dump(sample_metadata, f)
        metadata_path = f.name
    
    content, duration = generator.generate_tweet(
        metadata_path, "sample_video_01.mp4", "en"
    )
    
    assert content == "Enhanced tweet content with AI"
    mock_gemini.generate_content.assert_called_once()
    
    os.unlink(metadata_path)

def test_generate_tweet_missing_metadata():
    """测试缺失元数据的处理"""
    generator = ContentGenerator(use_ai=False)
    
    with pytest.raises(ValueError, match="无法读取元数据文件"):
        generator.generate_tweet("/nonexistent/path.json", "video.mp4", "en")

@pytest.mark.parametrize("language,expected_prefix", [
    ("en", "🎥 New Video:"),
    ("cn", "🎥 新视频："),
    ("ja", "🎥 新しい動画：")
])
def test_content_type_prefix(language, expected_prefix):
    """测试多语言前缀"""
    generator = ContentGenerator()
    prefix = generator._get_content_type_prefix("video", language)
    assert prefix == expected_prefix
```

**`test_publisher.py`**:
```python
def test_post_tweet_with_video_success(mock_tweepy):
    """测试成功发布视频推文"""
    publisher = TwitterPublisher("key", "secret", "token", "token_secret")
    
    # 创建临时视频文件
    with tempfile.NamedTemporaryFile(suffix='.mp4', delete=False) as f:
        f.write(b"fake video content")
        video_path = f.name
    
    tweet_info, duration = publisher.post_tweet_with_video(
        "Test tweet content", video_path
    )
    
    assert tweet_info["tweet_id"] == "1234567890"
    assert "twitter.com" in tweet_info["tweet_url"]
    assert duration > 0
    
    mock_tweepy['api'].media_upload.assert_called_once()
    mock_tweepy['client'].create_tweet.assert_called_once()
    
    os.unlink(video_path)

def test_post_tweet_file_not_found():
    """测试文件不存在的处理"""
    publisher = TwitterPublisher("key", "secret", "token", "token_secret")
    
    with pytest.raises(FileNotFoundError):
        publisher.post_tweet_with_video("Test", "/nonexistent/video.mp4")

def test_post_tweet_api_error(mock_tweepy):
    """测试API错误处理"""
    mock_tweepy['client'].create_tweet.side_effect = Exception("API Error")
    
    publisher = TwitterPublisher("key", "secret", "token", "token_secret")
    
    with tempfile.NamedTemporaryFile(suffix='.mp4', delete=False) as f:
        f.write(b"fake video content")
        video_path = f.name
    
    with pytest.raises(Exception, match="API Error"):
        publisher.post_tweet_with_video("Test", video_path)
    
    os.unlink(video_path)
```

**`test_project_manager.py`**:
```python
def test_scan_and_create_tasks(db_session, temp_project_dir, sample_metadata):
    """测试项目扫描和任务创建"""
    # 准备测试数据
    video_dir = Path(temp_project_dir) / "output_video_music"
    json_dir = Path(temp_project_dir) / "uploader_json"
    
    # 创建测试视频文件
    test_video = video_dir / "sample_video_01.mp4"
    test_video.write_bytes(b"fake video content")
    
    # 创建测试元数据文件
    metadata_file = json_dir / "en_prompt_results_batch.json"
    with open(metadata_file, 'w', encoding='utf-8') as f:
        json.dump(sample_metadata, f)
    
    # 执行扫描
    manager = ProjectManager(db_session, str(Path(temp_project_dir).parent), user_id=1)
    new_tasks = manager.scan_and_create_tasks("test_project", "en")
    
    assert new_tasks == 1
    
    # 验证数据库中的记录
    project = db_session.query(Project).filter_by(name="test_project").first()
    assert project is not None
    
    tasks = db_session.query(PublishingTask).filter_by(project_id=project.id).all()
    assert len(tasks) == 1
    assert tasks[0].status == "pending"

def test_scan_duplicate_tasks(db_session, temp_project_dir, sample_metadata):
    """测试重复扫描不创建重复任务"""
    # 准备测试数据（同上）
    video_dir = Path(temp_project_dir) / "output_video_music"
    json_dir = Path(temp_project_dir) / "uploader_json"
    
    test_video = video_dir / "sample_video_01.mp4"
    test_video.write_bytes(b"fake video content")
    
    metadata_file = json_dir / "en_prompt_results_batch.json"
    with open(metadata_file, 'w', encoding='utf-8') as f:
        json.dump(sample_metadata, f)
    
    manager = ProjectManager(db_session, str(Path(temp_project_dir).parent), user_id=1)
    
    # 第一次扫描
    new_tasks_1 = manager.scan_and_create_tasks("test_project", "en")
    assert new_tasks_1 == 1
    
    # 第二次扫描
    new_tasks_2 = manager.scan_and_create_tasks("test_project", "en")
    assert new_tasks_2 == 0  # 不应该创建新任务
```

**`test_task_scheduler.py`**:
```python
def test_get_next_pending_task(db_session, mock_tweepy, mock_gemini):
    """测试获取下一个待处理任务"""
    # 创建测试数据
    project = Project(name="test_project", user_id=1)
    db_session.add(project)
    db_session.commit()
    
    task = PublishingTask(
        project_id=project.id,
        media_path="/test/video.mp4",
        metadata_path="/test/metadata.json",
        language="en",
        status="pending",
        scheduled_at=datetime.utcnow() - timedelta(minutes=1)
    )
    db_session.add(task)
    db_session.commit()
    
    # 创建调度器
    config = {'scheduler': {'interval_minutes_min': 15, 'interval_minutes_max': 30, 'max_retries': 3}}
    publisher = TwitterPublisher("key", "secret", "token", "token_secret")
    generator = ContentGenerator()
    scheduler = TaskScheduler(db_session, publisher, generator, config)
    
    # 测试获取任务
    next_task = scheduler._get_next_pending_task()
    assert next_task is not None
    assert next_task.id == task.id
```

### 2. 数据库层测试 (`tests/unit/database/`)

**`test_models.py`**:
```python
def test_user_model(db_session):
    """测试用户模型"""
    user = User(username="testuser", role="admin")
    db_session.add(user)
    db_session.commit()
    
    assert user.id is not None
    assert user.username == "testuser"
    assert user.created_at is not None

def test_project_model(db_session):
    """测试项目模型"""
    user = User(username="testuser", role="admin")
    db_session.add(user)
    db_session.commit()
    
    project = Project(name="test_project", user_id=user.id, description="Test project")
    db_session.add(project)
    db_session.commit()
    
    assert project.id is not None
    assert project.user_id == user.id
    assert project.user.username == "testuser"

def test_publishing_task_content_data():
    """测试发布任务的内容数据序列化"""
    task = PublishingTask()
    
    test_data = {"title": "Test", "description": "Test description"}
    task.set_content_data(test_data)
    
    retrieved_data = task.get_content_data()
    assert retrieved_data == test_data
```

**`test_repository.py`**:
```python
def test_user_repository_create(db_session):
    """测试用户仓库创建功能"""
    repo = UserRepository(db_session)
    
    user_data = {"username": "testuser", "role": "editor"}
    user = repo.create(user_data)
    
    assert user.username == "testuser"
    assert user.role == "editor"
    assert user.id is not None

def test_project_repository_get_by_name_and_user(db_session):
    """测试项目仓库按名称和用户查询"""
    # 创建测试用户
    user = User(username="testuser", role="admin")
    db_session.add(user)
    db_session.commit()
    
    # 创建测试项目
    project = Project(name="test_project", user_id=user.id)
    db_session.add(project)
    db_session.commit()
    
    repo = ProjectRepository(db_session)
    found_project = repo.get_by_name_and_user("test_project", user.id)
    
    assert found_project is not None
    assert found_project.name == "test_project"
    assert found_project.user_id == user.id
```

### 3. API层测试 (`tests/unit/api/`)

**`test_dependencies.py`**:
```python
def test_api_key_auth_valid(test_config):
    """测试有效API密钥认证"""
    # 这里需要根据实际的API密钥认证逻辑进行测试
    pass

def test_api_key_auth_invalid():
    """测试无效API密钥认证"""
    # 测试无效密钥的处理
    pass

def test_pagination_params():
    """测试分页参数解析"""
    from api.dependencies import get_pagination_params
    
    # 模拟请求参数
    params = get_pagination_params(page=2, size=20)
    assert params["offset"] == 20
    assert params["limit"] == 20
```

**`test_middleware.py`**:
```python
def test_error_handling_middleware(test_client):
    """测试错误处理中间件"""
    # 触发一个会导致500错误的请求
    response = test_client.get("/api/v1/nonexistent-endpoint")
    
    # 验证错误响应格式
    assert response.status_code == 404
    assert "error" in response.json()

def test_rate_limit_middleware(test_client):
    """测试速率限制中间件"""
    # 快速发送多个请求
    responses = []
    for _ in range(10):
        response = test_client.get("/api/v1/dashboard/health")
        responses.append(response)
    
    # 检查是否有请求被限制
    status_codes = [r.status_code for r in responses]
    # 根据实际的速率限制配置进行断言
```

**B. 集成测试 (Integration Tests)**

*   **目标**: 验证模块间的交互，特别是与数据库的交互。
*   **位置**: `tests/integration/`

### 1. 数据库集成测试 (`tests/integration/database/`)

**`test_database_operations.py`**:
```python
def test_complete_project_workflow(db_session):
    """测试完整的项目工作流程"""
    # 1. 创建用户
    user_repo = UserRepository(db_session)
    user = user_repo.create({"username": "testuser", "role": "admin"})
    
    # 2. 创建项目
    project_repo = ProjectRepository(db_session)
    project = project_repo.create({
        "name": "test_project",
        "user_id": user.id,
        "description": "Test project"
    })
    
    # 3. 创建内容源
    content_source_repo = ContentSourceRepository(db_session)
    content_source = content_source_repo.create({
        "project_id": project.id,
        "file_path": "/test/video.mp4",
        "metadata_path": "/test/metadata.json",
        "file_type": "video",
        "language": "en"
    })
    
    # 4. 创建发布任务
    task_repo = PublishingTaskRepository(db_session)
    task = task_repo.create({
        "project_id": project.id,
        "content_source_id": content_source.id,
        "media_path": "/test/video.mp4",
        "metadata_path": "/test/metadata.json",
        "language": "en",
        "status": "pending"
    })
    
    # 验证关联关系
    assert task.project.name == "test_project"
    assert task.content_source.file_path == "/test/video.mp4"
    assert task.project.user.username == "testuser"
    
    # 5. 更新任务状态
    task_repo.update(task.id, {"status": "completed"})
    updated_task = task_repo.get_by_id(task.id)
    assert updated_task.status == "completed"

def test_database_constraints(db_session):
    """测试数据库约束"""
    user_repo = UserRepository(db_session)
    project_repo = ProjectRepository(db_session)
    
    # 创建用户
    user = user_repo.create({"username": "testuser", "role": "admin"})
    
    # 创建项目
    project_repo.create({
        "name": "test_project",
        "user_id": user.id
    })
    
    # 尝试创建同名项目（应该失败）
    with pytest.raises(Exception):
        project_repo.create({
            "name": "test_project",
            "user_id": user.id
        })

def test_foreign_key_constraints(db_session):
    """测试外键约束"""
    task_repo = PublishingTaskRepository(db_session)
    
    # 尝试创建关联到不存在项目的任务
    with pytest.raises(Exception):
        task_repo.create({
            "project_id": 99999,  # 不存在的项目ID
            "media_path": "/test/video.mp4",
            "metadata_path": "/test/metadata.json",
            "language": "en",
            "status": "pending"
        })
```

### 2. 业务流程集成测试 (`tests/integration/workflows/`)

**`test_scheduler_flow.py`**:
```python
def test_complete_scheduling_workflow(db_session, mock_tweepy, mock_gemini, temp_project_dir, sample_metadata):
    """测试完整的调度工作流程"""
    # 准备测试数据
    user = User(username="testuser", role="admin")
    db_session.add(user)
    db_session.commit()
    
    project = Project(name="test_project", user_id=user.id)
    db_session.add(project)
    db_session.commit()
    
    # 创建临时媒体文件
    video_path = Path(temp_project_dir) / "test_video.mp4"
    video_path.write_bytes(b"fake video content")
    
    metadata_path = Path(temp_project_dir) / "test_metadata.json"
    with open(metadata_path, 'w', encoding='utf-8') as f:
        json.dump(sample_metadata, f)
    
    # 创建发布任务
    task = PublishingTask(
        project_id=project.id,
        media_path=str(video_path),
        metadata_path=str(metadata_path),
        language="en",
        status="pending",
        scheduled_at=datetime.utcnow() - timedelta(minutes=1)
    )
    db_session.add(task)
    db_session.commit()
    
    # 创建调度器组件
    config = {
        'scheduler': {
            'interval_minutes_min': 15,
            'interval_minutes_max': 30,
            'max_retries': 3
        }
    }
    
    publisher = TwitterPublisher("key", "secret", "token", "token_secret")
    generator = ContentGenerator(use_ai=False)
    scheduler = TaskScheduler(db_session, publisher, generator, config)
    
    # 执行调度
    processed_count = scheduler.run_once()
    
    # 验证结果
    assert processed_count == 1
    
    # 检查任务状态
    updated_task = db_session.query(PublishingTask).filter_by(id=task.id).first()
    assert updated_task.status == "completed"
    assert updated_task.tweet_id == "1234567890"
    
    # 检查发布日志
    log = db_session.query(PublishingLog).filter_by(task_id=task.id).first()
    assert log is not None
    assert log.status == "success"
    
    # 验证API调用
    mock_tweepy['api'].media_upload.assert_called_once()
    mock_tweepy['client'].create_tweet.assert_called_once()

def test_scheduling_failure_retry(db_session, mock_tweepy, mock_gemini, temp_project_dir, sample_metadata):
    """测试调度失败重试机制"""
    # 设置API调用失败
    mock_tweepy['client'].create_tweet.side_effect = Exception("API Error")
    
    # 准备测试数据
    user = User(username="testuser", role="admin")
    db_session.add(user)
    db_session.commit()
    
    project = Project(name="test_project", user_id=user.id)
    db_session.add(project)
    db_session.commit()
    
    video_path = Path(temp_project_dir) / "test_video.mp4"
    video_path.write_bytes(b"fake video content")
    
    metadata_path = Path(temp_project_dir) / "test_metadata.json"
    with open(metadata_path, 'w', encoding='utf-8') as f:
        json.dump(sample_metadata, f)
    
    task = PublishingTask(
        project_id=project.id,
        media_path=str(video_path),
        metadata_path=str(metadata_path),
        language="en",
        status="pending",
        scheduled_at=datetime.utcnow() - timedelta(minutes=1),
        retry_count=0
    )
    db_session.add(task)
    db_session.commit()
    
    # 创建调度器
    config = {'scheduler': {'max_retries': 3}}
    publisher = TwitterPublisher("key", "secret", "token", "token_secret")
    generator = ContentGenerator(use_ai=False)
    scheduler = TaskScheduler(db_session, publisher, generator, config)
    
    # 执行调度（应该失败）
    processed_count = scheduler.run_once()
    
    # 验证结果
    assert processed_count == 1
    
    # 检查任务状态
    updated_task = db_session.query(PublishingTask).filter_by(id=task.id).first()
    assert updated_task.status == "failed"
    assert updated_task.retry_count == 1
    
    # 检查错误日志
    log = db_session.query(PublishingLog).filter_by(task_id=task.id).first()
    assert log is not None
    assert log.status == "error"
    assert "API Error" in log.error_message

def test_project_manager_integration(db_session, temp_project_dir, sample_metadata):
    """测试项目管理器集成流程"""
    # 准备测试项目结构
    project_root = Path(temp_project_dir)
    video_dir = project_root / "output_video_music"
    json_dir = project_root / "uploader_json"
    
    video_dir.mkdir(parents=True)
    json_dir.mkdir(parents=True)
    
    # 创建测试文件
    test_video = video_dir / "sample_video_01.mp4"
    test_video.write_bytes(b"fake video content")
    
    metadata_file = json_dir / "en_prompt_results_batch.json"
    with open(metadata_file, 'w', encoding='utf-8') as f:
        json.dump(sample_metadata, f)
    
    # 创建用户
    user = User(username="testuser", role="admin")
    db_session.add(user)
    db_session.commit()
    
    # 执行项目管理器扫描
    manager = ProjectManager(db_session, str(project_root.parent), user_id=user.id)
    new_tasks = manager.scan_and_create_tasks("test_project", "en")
    
    assert new_tasks == 1
    
    # 验证数据库记录
    project = db_session.query(Project).filter_by(name="test_project").first()
    assert project is not None
    assert project.user_id == user.id
    
    content_source = db_session.query(ContentSource).filter_by(project_id=project.id).first()
    assert content_source is not None
    assert content_source.file_type == "video"
    
    task = db_session.query(PublishingTask).filter_by(project_id=project.id).first()
    assert task is not None
    assert task.status == "pending"
    assert task.language == "en"
```

### 3. API集成测试 (`tests/integration/api/`)

**`test_api_workflows.py`**:
```python
def test_project_management_api_flow(test_client, db_session):
    """测试项目管理API完整流程"""
    # 1. 创建项目
    project_data = {
        "name": "test_project",
        "description": "Test project description",
        "language": "en"
    }
    
    response = test_client.post("/api/v1/projects", json=project_data)
    assert response.status_code == 201
    project_id = response.json()["id"]
    
    # 2. 获取项目列表
    response = test_client.get("/api/v1/projects")
    assert response.status_code == 200
    projects = response.json()["items"]
    assert len(projects) == 1
    assert projects[0]["name"] == "test_project"
    
    # 3. 获取单个项目
    response = test_client.get(f"/api/v1/projects/{project_id}")
    assert response.status_code == 200
    project = response.json()
    assert project["name"] == "test_project"
    
    # 4. 更新项目
    update_data = {"description": "Updated description"}
    response = test_client.put(f"/api/v1/projects/{project_id}", json=update_data)
    assert response.status_code == 200
    
    # 5. 验证更新
    response = test_client.get(f"/api/v1/projects/{project_id}")
    assert response.json()["description"] == "Updated description"
    
    # 6. 删除项目
    response = test_client.delete(f"/api/v1/projects/{project_id}")
    assert response.status_code == 204
    
    # 7. 验证删除
    response = test_client.get(f"/api/v1/projects/{project_id}")
    assert response.status_code == 404

def test_task_management_api_flow(test_client, db_session):
    """测试任务管理API完整流程"""
    # 先创建项目
    project_data = {"name": "test_project", "language": "en"}
    response = test_client.post("/api/v1/projects", json=project_data)
    project_id = response.json()["id"]
    
    # 1. 扫描项目创建任务
    response = test_client.post(f"/api/v1/projects/{project_id}/scan")
    assert response.status_code == 200
    
    # 2. 获取任务列表
    response = test_client.get("/api/v1/tasks")
    assert response.status_code == 200
    
    # 3. 手动触发任务执行
    response = test_client.post("/api/v1/tasks/execute")
    assert response.status_code == 200
    
    # 4. 获取任务统计
    response = test_client.get("/api/v1/tasks/stats")
    assert response.status_code == 200
    stats = response.json()
    assert "total" in stats
    assert "pending" in stats
    assert "completed" in stats

def test_dashboard_api_integration(test_client, db_session):
    """测试仪表板API集成"""
    # 1. 健康检查
    response = test_client.get("/api/v1/dashboard/health")
    assert response.status_code == 200
    health = response.json()
    assert health["status"] == "healthy"
    
    # 2. 系统统计
    response = test_client.get("/api/v1/dashboard/stats")
    assert response.status_code == 200
    stats = response.json()
    assert "projects" in stats
    assert "tasks" in stats
    assert "users" in stats
    
    # 3. 最近活动
    response = test_client.get("/api/v1/dashboard/recent-activity")
    assert response.status_code == 200
    activity = response.json()
    assert "items" in activity
```

**C. 端到端测试 (E2E Tests)**

*   **目标**: 模拟用户真实使用场景，验证整个系统的完整性。
*   **位置**: `tests/e2e/`
*   **重要提示**: 这些测试标记为 `@pytest.mark.e2e`。默认情况下可以配置 `pytest` 跳过它们，只在专门的 E2E 测试阶段运行。**凡涉及真实 API 的测试，必须使用专用的、无商业价值的测试 Twitter 账号和 API Key。**

### 1. CLI端到端测试 (`tests/e2e/cli/`)

**`test_cli_flow.py`**:
```python
@pytest.mark.e2e
def test_complete_cli_workflow(runner, db_session, temp_project_dir, sample_metadata, mock_tweepy, mock_gemini):
    """测试完整的CLI工作流程"""
    # 1. 准备测试项目结构
    project_root = Path(temp_project_dir)
    video_dir = project_root / "output_video_music"
    json_dir = project_root / "uploader_json"
    
    video_dir.mkdir(parents=True)
    json_dir.mkdir(parents=True)
    
    # 创建测试文件
    test_video = video_dir / "sample_video_01.mp4"
    test_video.write_bytes(b"fake video content")
    
    metadata_file = json_dir / "en_prompt_results_batch.json"
    with open(metadata_file, 'w', encoding='utf-8') as f:
        json.dump(sample_metadata, f)
    
    # 2. 执行项目扫描
    result = runner.invoke(cli, [
        'scan',
        '--project-root', str(project_root.parent),
        '--project', 'test_project',
        '--language', 'en'
    ])
    
    assert result.exit_code == 0
    assert "扫描完成" in result.output
    
    # 验证数据库中的记录
    project = db_session.query(Project).filter_by(name="test_project").first()
    assert project is not None
    
    tasks = db_session.query(PublishingTask).filter_by(project_id=project.id).all()
    assert len(tasks) == 1
    assert tasks[0].status == "pending"
    
    # 3. 执行发布任务
    result = runner.invoke(cli, [
        'publish',
        '--limit', '1',
        '--dry-run', 'false'
    ])
    
    assert result.exit_code == 0
    assert "发布完成" in result.output
    
    # 验证任务状态更新
    updated_task = db_session.query(PublishingTask).filter_by(id=tasks[0].id).first()
    assert updated_task.status == "completed"
    
    # 验证发布日志
    log = db_session.query(PublishingLog).filter_by(task_id=tasks[0].id).first()
    assert log is not None
    assert log.status == "success"

@pytest.mark.e2e
def test_database_maintenance_commands(runner, db_session):
    """测试数据库维护命令"""
    # 创建一些测试数据
    user = User(username="testuser", role="admin")
    db_session.add(user)
    db_session.commit()
    
    project = Project(name="old_project", user_id=user.id)
    db_session.add(project)
    db_session.commit()
    
    # 创建一个旧的发布日志
    old_log = PublishingLog(
        task_id=1,
        status="success",
        created_at=datetime.utcnow() - timedelta(days=31)
    )
    db_session.add(old_log)
    db_session.commit()
    
    # 1. 测试数据库统计
    result = runner.invoke(cli, ['db:stats'])
    assert result.exit_code == 0
    assert "项目数量" in result.output
    
    # 2. 测试数据清理
    result = runner.invoke(cli, ['db:purge', '--days', '30', '--confirm'])
    assert result.exit_code == 0
    assert "清理完成" in result.output
    
    # 验证旧数据被删除
    remaining_logs = db_session.query(PublishingLog).filter(
        PublishingLog.created_at < datetime.utcnow() - timedelta(days=30)
    ).count()
    assert remaining_logs == 0
    
    # 3. 测试数据库健康检查
    result = runner.invoke(cli, ['db:health'])
    assert result.exit_code == 0
    assert "数据库连接正常" in result.output

@pytest.mark.e2e
def test_project_management_cli(runner, db_session, temp_project_dir):
    """测试项目管理CLI命令"""
    # 1. 列出项目（应该为空）
    result = runner.invoke(cli, ['project:list'])
    assert result.exit_code == 0
    assert "暂无项目" in result.output
    
    # 2. 创建项目
    result = runner.invoke(cli, [
        'project:create',
        '--name', 'test_project',
        '--description', 'Test project description',
        '--language', 'en'
    ])
    assert result.exit_code == 0
    assert "项目创建成功" in result.output
    
    # 3. 列出项目（应该有一个）
    result = runner.invoke(cli, ['project:list'])
    assert result.exit_code == 0
    assert "test_project" in result.output
    
    # 4. 获取项目详情
    result = runner.invoke(cli, ['project:info', '--name', 'test_project'])
    assert result.exit_code == 0
    assert "test_project" in result.output
    assert "Test project description" in result.output
```

### 2. API端到端测试 (`tests/e2e/api/`)

**`test_api_e2e.py`**:
```python
@pytest.mark.e2e
def test_complete_api_workflow(test_client, db_session, temp_project_dir, sample_metadata):
    """测试完整的API工作流程"""
    # 1. 创建用户和API密钥
    user = User(username="testuser", role="admin")
    db_session.add(user)
    db_session.commit()
    
    api_key = ApiKey(
        user_id=user.id,
        key_hash="test_key_hash",
        name="Test API Key"
    )
    db_session.add(api_key)
    db_session.commit()
    
    # 设置认证头
    headers = {"X-API-Key": "test_key"}
    
    # 2. 创建项目
    project_data = {
        "name": "api_test_project",
        "description": "API test project",
        "language": "en"
    }
    
    response = test_client.post("/api/v1/projects", json=project_data, headers=headers)
    assert response.status_code == 201
    project_id = response.json()["id"]
    
    # 3. 准备项目文件
    project_root = Path(temp_project_dir)
    video_dir = project_root / "output_video_music"
    json_dir = project_root / "uploader_json"
    
    video_dir.mkdir(parents=True)
    json_dir.mkdir(parents=True)
    
    test_video = video_dir / "sample_video_01.mp4"
    test_video.write_bytes(b"fake video content")
    
    metadata_file = json_dir / "en_prompt_results_batch.json"
    with open(metadata_file, 'w', encoding='utf-8') as f:
        json.dump(sample_metadata, f)
    
    # 4. 扫描项目
    response = test_client.post(
        f"/api/v1/projects/{project_id}/scan",
        json={"project_root": str(project_root.parent)},
        headers=headers
    )
    assert response.status_code == 200
    scan_result = response.json()
    assert scan_result["new_tasks"] == 1
    
    # 5. 获取任务列表
    response = test_client.get("/api/v1/tasks", headers=headers)
    assert response.status_code == 200
    tasks = response.json()["items"]
    assert len(tasks) == 1
    
    # 6. 执行任务
    response = test_client.post("/api/v1/tasks/execute", headers=headers)
    assert response.status_code == 200
    
    # 7. 检查任务状态
    task_id = tasks[0]["id"]
    response = test_client.get(f"/api/v1/tasks/{task_id}", headers=headers)
    assert response.status_code == 200
    task = response.json()
    assert task["status"] in ["completed", "processing"]
    
    # 8. 获取项目统计
    response = test_client.get(f"/api/v1/projects/{project_id}/stats", headers=headers)
    assert response.status_code == 200
    stats = response.json()
    assert stats["total_tasks"] == 1

@pytest.mark.e2e
def test_api_error_handling(test_client):
    """测试API错误处理"""
    # 1. 未认证请求
    response = test_client.get("/api/v1/projects")
    assert response.status_code == 401
    
    # 2. 无效API密钥
    headers = {"X-API-Key": "invalid_key"}
    response = test_client.get("/api/v1/projects", headers=headers)
    assert response.status_code == 401
    
    # 3. 不存在的资源
    headers = {"X-API-Key": "test_key"}
    response = test_client.get("/api/v1/projects/99999", headers=headers)
    assert response.status_code == 404
    
    # 4. 无效请求数据
    response = test_client.post(
        "/api/v1/projects",
        json={"invalid_field": "value"},
        headers=headers
    )
    assert response.status_code == 422
```

### 3. 真实API测试 (`tests/e2e/real_api/`)

**`test_real_twitter_api.py`**:
```python
@pytest.mark.e2e_real_api
@pytest.mark.skipif(
    not os.getenv("TWITTER_TEST_API_KEY"),
    reason="需要真实的Twitter测试API密钥"
)
def test_real_twitter_publishing(db_session, temp_project_dir):
    """测试真实Twitter API发布（需要测试账号）"""
    # 警告：此测试使用真实API，仅在测试环境中运行
    
    # 1. 配置真实API密钥
    api_key = os.getenv("TWITTER_TEST_API_KEY")
    api_secret = os.getenv("TWITTER_TEST_API_SECRET")
    access_token = os.getenv("TWITTER_TEST_ACCESS_TOKEN")
    access_token_secret = os.getenv("TWITTER_TEST_ACCESS_TOKEN_SECRET")
    
    # 2. 创建极小的测试媒体文件
    test_video_path = Path(temp_project_dir) / "test_video.mp4"
    # 创建一个极小的测试视频（实际项目中应该是有效的视频文件）
    test_video_path.write_bytes(b"fake minimal video content")
    
    # 3. 创建测试推文内容
    test_content = f"🧪 自动化测试推文 - {datetime.now().strftime('%Y%m%d_%H%M%S')} #测试 #自动化"
    
    # 4. 执行发布
    publisher = TwitterPublisher(api_key, api_secret, access_token, access_token_secret)
    
    try:
        # 发布推文
        tweet_info, duration = publisher.post_tweet_with_video(
            test_content, str(test_video_path)
        )
        
        # 验证发布成功
        assert "tweet_id" in tweet_info
        assert "tweet_url" in tweet_info
        assert duration > 0
        
        tweet_id = tweet_info["tweet_id"]
        
        # 记录发布日志
        log = PublishingLog(
            task_id=0,  # 测试任务
            status="success",
            tweet_id=tweet_id,
            tweet_url=tweet_info["tweet_url"],
            execution_time=duration
        )
        db_session.add(log)
        db_session.commit()
        
        print(f"✅ 测试推文发布成功: {tweet_info['tweet_url']}")
        
    except Exception as e:
        pytest.fail(f"真实API测试失败: {str(e)}")
    
    finally:
        # 5. 清理：删除测试推文
        try:
            if 'tweet_id' in locals():
                # 注意：Twitter API v2 删除推文需要特殊权限
                # 在实际测试中，可能需要手动清理或使用测试账号
                print(f"⚠️  请手动删除测试推文: {tweet_id}")
        except Exception as cleanup_error:
            print(f"⚠️  清理测试推文失败: {cleanup_error}")

@pytest.mark.e2e_real_api
def test_twitter_api_error_handling():
    """测试Twitter API错误处理"""
    # 使用无效的API密钥测试错误处理
    publisher = TwitterPublisher("invalid", "invalid", "invalid", "invalid")
    
    with pytest.raises(Exception):
        publisher.verify_credentials()
```

#### **四、 测试执行与持续集成**

*   **本地执行**:
    *   运行所有快速测试: `pytest`
    *   运行包括慢速的集成测试: `pytest --runslow`
    *   仅运行 E2E 测试: `pytest -m e2e`
*   **CI/CD 集成 (GitHub Actions)**:
    *   在 CI 工作流中，执行 `pytest` 命令。这会运行所有单元和集成测试。
    *   可以创建一个独立的、需要手动触发 (workflow_dispatch) 或定时触发的 E2E 测试工作流，该工作流会设置好真实的测试 API 密钥（通过 GitHub Secrets），然后执行 `pytest -m e2e`。

这个全面的测试方案确保了从最小的逻辑单元到整个系统的端到端流程都得到了充分的验证，同时通过分层和独立的设计，保持了测试的高效性和可维护性。