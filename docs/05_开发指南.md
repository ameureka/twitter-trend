# 开发指南

## 开发环境搭建

### 系统要求

- **Python**: 3.8+
- **操作系统**: Windows 10+, macOS 10.15+, Ubuntu 18.04+
- **内存**: 最低 4GB，推荐 8GB+
- **磁盘空间**: 最低 2GB 可用空间

### 环境准备

#### 1. 克隆项目

```bash
git clone https://github.com/your-org/twitter-auto-publisher.git
cd twitter-auto-publisher
```

#### 2. 创建虚拟环境

```bash
# 使用 venv
python -m venv venv

# 激活虚拟环境
# Windows
venv\Scripts\activate
# macOS/Linux
source venv/bin/activate
```

#### 3. 安装依赖

```bash
# 安装基础依赖
pip install -r requirements.txt

# 安装开发依赖
pip install -r requirements-dev.txt

# 验证安装
python -m app.cli health
```

#### 4. 配置开发环境

```bash
# 复制环境变量模板
cp .env.example .env

# 编辑环境变量
vim .env

# 初始化数据库
python -m app.cli db init

# 运行系统验证
python -m app.cli validate
```

### IDE配置

#### VS Code 推荐配置

创建 `.vscode/settings.json`:

```json
{
    "python.defaultInterpreterPath": "./venv/bin/python",
    "python.linting.enabled": true,
    "python.linting.pylintEnabled": true,
    "python.linting.flake8Enabled": true,
    "python.formatting.provider": "black",
    "python.formatting.blackArgs": ["--line-length=88"],
    "python.sortImports.args": ["--profile", "black"],
    "editor.formatOnSave": true,
    "editor.codeActionsOnSave": {
        "source.organizeImports": true
    },
    "files.exclude": {
        "**/__pycache__": true,
        "**/*.pyc": true,
        ".pytest_cache": true,
        ".coverage": true
    }
}
```

推荐扩展:
- Python
- Pylance
- Black Formatter
- isort
- GitLens
- Docker

#### PyCharm 配置

1. **解释器设置**: File → Settings → Project → Python Interpreter
2. **代码风格**: File → Settings → Editor → Code Style → Python
3. **检查工具**: File → Settings → Editor → Inspections → Python

## 项目结构

### 目录结构

```
twitter-auto-publisher/
├── app/                          # 应用核心代码
│   ├── __init__.py
│   ├── main.py                   # 应用入口
│   ├── cli.py                    # 命令行接口
│   ├── api/                      # API相关
│   │   ├── __init__.py
│   │   ├── main.py              # FastAPI应用
│   │   ├── routes/              # API路由
│   │   ├── middleware/          # 中间件
│   │   └── dependencies.py     # 依赖注入
│   ├── core/                    # 核心业务逻辑
│   │   ├── __init__.py
│   │   ├── scheduler.py         # 任务调度器
│   │   ├── publisher.py         # 发布服务
│   │   ├── content_generator.py # 内容生成器
│   │   └── enhanced_scheduler.py # 增强调度器
│   ├── database/                # 数据库相关
│   │   ├── __init__.py
│   │   ├── models.py           # 数据模型
│   │   ├── db_manager.py       # 数据库管理
│   │   ├── migrations/         # 数据库迁移
│   │   └── schemas/            # 数据库架构
│   ├── services/               # 外部服务集成
│   │   ├── __init__.py
│   │   ├── twitter_service.py  # Twitter API
│   │   ├── gemini_service.py   # Gemini AI
│   │   └── notification_service.py # 通知服务
│   ├── utils/                  # 工具模块
│   │   ├── __init__.py
│   │   ├── config.py           # 配置管理
│   │   ├── logger.py           # 日志工具
│   │   ├── error_handler.py    # 错误处理
│   │   ├── performance_monitor.py # 性能监控
│   │   ├── retry_handler.py    # 重试机制
│   │   ├── config_validator.py # 配置验证
│   │   └── system_validator.py # 系统验证
│   └── web/                    # Web界面
│       ├── static/             # 静态资源
│       ├── templates/          # 模板文件
│       └── assets/             # 前端资源
├── config/                     # 配置文件
│   ├── config.yaml            # 主配置
│   ├── development.yaml       # 开发环境
│   ├── testing.yaml           # 测试环境
│   └── production.yaml        # 生产环境
├── data/                      # 数据目录
│   ├── database/              # 数据库文件
│   ├── backups/               # 备份文件
│   └── uploads/               # 上传文件
├── docs/                      # 文档
├── logs/                      # 日志文件
├── scripts/                   # 脚本工具
│   ├── setup.py              # 安装脚本
│   ├── deploy.py              # 部署脚本
│   └── migrate.py             # 迁移脚本
├── tests/                     # 测试代码
│   ├── unit/                  # 单元测试
│   ├── integration/           # 集成测试
│   ├── e2e/                   # 端到端测试
│   └── fixtures/              # 测试数据
├── tools/                     # 开发工具
│   ├── schema_migrator.py     # 数据库迁移工具
│   ├── config_key_manager.py  # 配置密钥管理
│   └── performance_analyzer.py # 性能分析工具
├── docker/                    # Docker相关
│   ├── Dockerfile
│   ├── docker-compose.yml
│   └── docker-compose.dev.yml
├── .env.example              # 环境变量模板
├── .gitignore               # Git忽略文件
├── requirements.txt         # 生产依赖
├── requirements-dev.txt     # 开发依赖
├── pyproject.toml          # 项目配置
└── README.md               # 项目说明
```

### 模块设计原则

#### 1. 模块化和解耦

- **单一职责**: 每个模块只负责一个特定功能
- **低耦合**: 模块间依赖最小化
- **高内聚**: 模块内部功能紧密相关
- **接口隔离**: 通过接口定义模块边界

```python
# 良好的模块设计示例
from abc import ABC, abstractmethod
from typing import Protocol

class PublisherProtocol(Protocol):
    """发布服务协议"""
    def publish(self, content: str, media: Optional[str] = None) -> bool:
        ...

class TwitterPublisher:
    """Twitter发布实现"""
    def __init__(self, api_client: TwitterAPI):
        self._api = api_client
    
    def publish(self, content: str, media: Optional[str] = None) -> bool:
        # 实现发布逻辑
        pass
```

#### 2. 依赖注入

```python
# 使用依赖注入提高可测试性
class ContentService:
    def __init__(
        self,
        publisher: PublisherProtocol,
        generator: ContentGenerator,
        validator: ContentValidator
    ):
        self._publisher = publisher
        self._generator = generator
        self._validator = validator
    
    def process_content(self, source: str) -> bool:
        content = self._generator.generate(source)
        if self._validator.validate(content):
            return self._publisher.publish(content)
        return False
```

## 代码规范

### 1. Python代码风格

遵循 [PEP 8](https://pep8.org/) 和项目特定规范:

#### 命名规范

```python
# 类名: PascalCase
class DatabaseManager:
    pass

# 函数和变量: snake_case
def get_user_data():
    user_name = "example"
    return user_name

# 常量: UPPER_SNAKE_CASE
MAX_RETRY_ATTEMPTS = 3
DEFAULT_TIMEOUT = 30

# 私有成员: 前缀下划线
class MyClass:
    def __init__(self):
        self._private_var = "private"
        self.__very_private = "very private"
```

#### 类型注解

```python
from typing import List, Dict, Optional, Union, Callable
from pathlib import Path

def process_files(
    file_paths: List[Path],
    processor: Callable[[Path], bool],
    options: Optional[Dict[str, Union[str, int]]] = None
) -> Dict[str, bool]:
    """处理文件列表
    
    Args:
        file_paths: 文件路径列表
        processor: 文件处理函数
        options: 可选配置参数
    
    Returns:
        处理结果字典，键为文件路径，值为处理是否成功
    """
    results = {}
    for path in file_paths:
        try:
            results[str(path)] = processor(path)
        except Exception as e:
            logger.error(f"处理文件失败 {path}: {e}")
            results[str(path)] = False
    return results
```

#### 文档字符串

```python
def calculate_metrics(
    data: List[float],
    include_variance: bool = True
) -> Dict[str, float]:
    """计算数据指标
    
    计算给定数据的基本统计指标，包括均值、标准差等。
    
    Args:
        data: 数值数据列表
        include_variance: 是否包含方差计算
    
    Returns:
        包含各项指标的字典:
        - mean: 平均值
        - std: 标准差
        - variance: 方差 (如果 include_variance=True)
    
    Raises:
        ValueError: 当数据列表为空时
        TypeError: 当数据包含非数值类型时
    
    Example:
        >>> data = [1.0, 2.0, 3.0, 4.0, 5.0]
        >>> metrics = calculate_metrics(data)
        >>> print(metrics['mean'])
        3.0
    """
    if not data:
        raise ValueError("数据列表不能为空")
    
    # 实现计算逻辑
    pass
```

### 2. 错误处理

#### 异常处理最佳实践

```python
import logging
from typing import Optional
from app.utils.error_handler import handle_error, RetryableError

logger = logging.getLogger(__name__)

def robust_api_call(endpoint: str, data: dict) -> Optional[dict]:
    """健壮的API调用"""
    try:
        response = api_client.post(endpoint, json=data)
        response.raise_for_status()
        return response.json()
    
    except requests.exceptions.Timeout as e:
        # 超时错误 - 可重试
        logger.warning(f"API调用超时: {endpoint}")
        raise RetryableError(f"API超时: {e}") from e
    
    except requests.exceptions.HTTPError as e:
        if e.response.status_code >= 500:
            # 服务器错误 - 可重试
            logger.error(f"服务器错误: {e.response.status_code}")
            raise RetryableError(f"服务器错误: {e}") from e
        else:
            # 客户端错误 - 不可重试
            logger.error(f"客户端错误: {e.response.status_code}")
            handle_error(e, context={"endpoint": endpoint, "data": data})
            return None
    
    except Exception as e:
        # 未知错误
        logger.exception(f"API调用失败: {endpoint}")
        handle_error(e, context={"endpoint": endpoint})
        return None
```

#### 自定义异常

```python
class TwitterPublisherError(Exception):
    """Twitter发布相关错误基类"""
    pass

class AuthenticationError(TwitterPublisherError):
    """认证错误"""
    pass

class RateLimitError(TwitterPublisherError):
    """频率限制错误"""
    def __init__(self, message: str, retry_after: int):
        super().__init__(message)
        self.retry_after = retry_after

class ContentValidationError(TwitterPublisherError):
    """内容验证错误"""
    def __init__(self, message: str, field: str, value: str):
        super().__init__(message)
        self.field = field
        self.value = value
```

### 3. 日志记录

#### 结构化日志

```python
import logging
import json
from datetime import datetime
from typing import Dict, Any

class StructuredLogger:
    """结构化日志记录器"""
    
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
    
    def log_event(
        self,
        level: str,
        message: str,
        event_type: str,
        **kwargs
    ) -> None:
        """记录结构化事件"""
        log_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": level.upper(),
            "message": message,
            "event_type": event_type,
            **kwargs
        }
        
        getattr(self.logger, level.lower())(json.dumps(log_data))
    
    def log_performance(
        self,
        operation: str,
        duration: float,
        success: bool,
        **metadata
    ) -> None:
        """记录性能指标"""
        self.log_event(
            "info",
            f"操作完成: {operation}",
            "performance",
            operation=operation,
            duration_ms=duration * 1000,
            success=success,
            **metadata
        )

# 使用示例
logger = StructuredLogger(__name__)

def publish_content(content: str) -> bool:
    start_time = time.time()
    try:
        # 发布逻辑
        result = twitter_api.post(content)
        
        logger.log_event(
            "info",
            "内容发布成功",
            "content_published",
            content_length=len(content),
            tweet_id=result.get("id")
        )
        return True
    
    except Exception as e:
        logger.log_event(
            "error",
            f"内容发布失败: {e}",
            "content_publish_failed",
            content_length=len(content),
            error_type=type(e).__name__
        )
        return False
    
    finally:
        duration = time.time() - start_time
        logger.log_performance(
            "publish_content",
            duration,
            success=True  # 根据实际结果设置
        )
```

## 测试指南

### 1. 测试结构

```
tests/
├── unit/                    # 单元测试
│   ├── test_database/
│   ├── test_services/
│   ├── test_utils/
│   └── test_core/
├── integration/             # 集成测试
│   ├── test_api/
│   ├── test_database/
│   └── test_workflows/
├── e2e/                     # 端到端测试
│   ├── test_publishing/
│   └── test_scheduling/
├── fixtures/                # 测试数据
│   ├── sample_content/
│   ├── mock_responses/
│   └── test_configs/
└── conftest.py             # pytest配置
```

### 2. 单元测试

```python
import pytest
from unittest.mock import Mock, patch, MagicMock
from app.core.publisher import ContentPublisher
from app.services.twitter_service import TwitterService
from app.utils.error_handler import RateLimitError

class TestContentPublisher:
    """内容发布器测试"""
    
    @pytest.fixture
    def mock_twitter_service(self):
        """模拟Twitter服务"""
        service = Mock(spec=TwitterService)
        service.post_tweet.return_value = {"id": "123456", "text": "test"}
        return service
    
    @pytest.fixture
    def publisher(self, mock_twitter_service):
        """创建发布器实例"""
        return ContentPublisher(twitter_service=mock_twitter_service)
    
    def test_publish_success(self, publisher, mock_twitter_service):
        """测试成功发布"""
        content = "测试内容"
        
        result = publisher.publish(content)
        
        assert result is True
        mock_twitter_service.post_tweet.assert_called_once_with(content, None)
    
    def test_publish_with_media(self, publisher, mock_twitter_service):
        """测试带媒体发布"""
        content = "测试内容"
        media_path = "/path/to/image.jpg"
        
        result = publisher.publish(content, media_path)
        
        assert result is True
        mock_twitter_service.post_tweet.assert_called_once_with(content, media_path)
    
    def test_publish_rate_limit_error(self, publisher, mock_twitter_service):
        """测试频率限制错误"""
        mock_twitter_service.post_tweet.side_effect = RateLimitError(
            "Rate limit exceeded", retry_after=900
        )
        
        with pytest.raises(RateLimitError) as exc_info:
            publisher.publish("测试内容")
        
        assert exc_info.value.retry_after == 900
    
    @pytest.mark.parametrize("content,expected", [
        ("", False),  # 空内容
        ("a" * 281, False),  # 超长内容
        ("正常内容", True),  # 正常内容
    ])
    def test_content_validation(self, publisher, content, expected):
        """测试内容验证"""
        result = publisher.validate_content(content)
        assert result == expected
```

### 3. 集成测试

```python
import pytest
import tempfile
from pathlib import Path
from app.database.db_manager import DatabaseManager
from app.core.scheduler import TaskScheduler

@pytest.fixture
def temp_db():
    """临时数据库"""
    with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as f:
        db_path = f.name
    
    yield db_path
    
    # 清理
    Path(db_path).unlink(missing_ok=True)

class TestTaskSchedulerIntegration:
    """任务调度器集成测试"""
    
    def test_schedule_and_execute_task(self, temp_db):
        """测试任务调度和执行"""
        # 初始化组件
        db_manager = DatabaseManager(db_path=temp_db)
        db_manager.initialize_database()
        
        scheduler = TaskScheduler(db_manager=db_manager)
        
        # 创建测试任务
        task_data = {
            "project_id": 1,
            "content_path": "/test/content.txt",
            "media_path": "/test/image.jpg",
            "language": "cn"
        }
        
        # 调度任务
        task_id = scheduler.schedule_task(**task_data)
        assert task_id is not None
        
        # 验证任务已保存
        tasks = scheduler.get_pending_tasks()
        assert len(tasks) == 1
        assert tasks[0]["id"] == task_id
        
        # 执行任务
        with patch('app.core.publisher.ContentPublisher.publish') as mock_publish:
            mock_publish.return_value = True
            
            result = scheduler.execute_task(task_id)
            assert result is True
            
            # 验证任务状态更新
            task = scheduler.get_task(task_id)
            assert task["status"] == "completed"
```

### 4. 端到端测试

```python
import pytest
import requests
from pathlib import Path
from app.api.main import create_app
from fastapi.testclient import TestClient

@pytest.fixture
def test_client():
    """测试客户端"""
    app = create_app()
    return TestClient(app)

class TestPublishingWorkflow:
    """发布工作流端到端测试"""
    
    def test_complete_publishing_workflow(self, test_client):
        """测试完整发布流程"""
        # 1. 创建项目
        project_data = {
            "name": "测试项目",
            "path": "/tmp/test_project"
        }
        response = test_client.post("/api/projects", json=project_data)
        assert response.status_code == 201
        project_id = response.json()["id"]
        
        # 2. 扫描项目内容
        response = test_client.post(f"/api/projects/{project_id}/scan")
        assert response.status_code == 200
        
        # 3. 获取待发布任务
        response = test_client.get(f"/api/projects/{project_id}/tasks")
        assert response.status_code == 200
        tasks = response.json()
        assert len(tasks) > 0
        
        # 4. 执行发布任务
        task_id = tasks[0]["id"]
        response = test_client.post(f"/api/tasks/{task_id}/publish")
        assert response.status_code == 200
        
        # 5. 验证发布结果
        response = test_client.get(f"/api/tasks/{task_id}")
        assert response.status_code == 200
        task = response.json()
        assert task["status"] == "completed"
```

### 5. 测试运行

```bash
# 运行所有测试
pytest

# 运行特定测试
pytest tests/unit/test_publisher.py

# 运行带覆盖率的测试
pytest --cov=app --cov-report=html

# 运行性能测试
pytest tests/performance/ --benchmark-only

# 运行并行测试
pytest -n auto

# 运行特定标记的测试
pytest -m "not slow"
```

## 性能优化

### 1. 代码性能

#### 使用生成器和迭代器

```python
# 不好的做法 - 内存占用大
def process_all_files(directory: Path) -> List[str]:
    results = []
    for file_path in directory.rglob("*.txt"):
        with open(file_path) as f:
            content = f.read()
            processed = process_content(content)
            results.append(processed)
    return results

# 好的做法 - 使用生成器
def process_files_generator(directory: Path) -> Iterator[str]:
    for file_path in directory.rglob("*.txt"):
        with open(file_path) as f:
            content = f.read()
            yield process_content(content)

# 使用
for result in process_files_generator(Path("/data")):
    handle_result(result)
```

#### 缓存和记忆化

```python
from functools import lru_cache, wraps
from typing import Dict, Any
import time

# LRU缓存
@lru_cache(maxsize=128)
def expensive_computation(param: str) -> str:
    # 模拟耗时计算
    time.sleep(1)
    return f"result_for_{param}"

# 带过期时间的缓存
def timed_cache(seconds: int):
    def decorator(func):
        cache = {}
        
        @wraps(func)
        def wrapper(*args, **kwargs):
            key = str(args) + str(sorted(kwargs.items()))
            now = time.time()
            
            if key in cache:
                result, timestamp = cache[key]
                if now - timestamp < seconds:
                    return result
            
            result = func(*args, **kwargs)
            cache[key] = (result, now)
            return result
        
        return wrapper
    return decorator

@timed_cache(300)  # 5分钟缓存
def get_api_data(endpoint: str) -> Dict[str, Any]:
    response = requests.get(endpoint)
    return response.json()
```

### 2. 数据库性能

#### 查询优化

```python
# 使用索引
CREATE INDEX idx_tasks_status_created ON publishing_tasks(status, created_at);
CREATE INDEX idx_logs_task_id ON publishing_logs(task_id);

# 批量操作
def batch_insert_tasks(tasks: List[Dict[str, Any]]) -> None:
    """批量插入任务"""
    with get_db_connection() as conn:
        conn.executemany(
            """
            INSERT INTO publishing_tasks 
            (project_id, content_path, media_path, language, status)
            VALUES (?, ?, ?, ?, ?)
            """,
            [(t['project_id'], t['content_path'], t['media_path'], 
              t['language'], t['status']) for t in tasks]
        )
        conn.commit()

# 分页查询
def get_tasks_paginated(
    page: int = 1, 
    page_size: int = 50
) -> Dict[str, Any]:
    """分页获取任务"""
    offset = (page - 1) * page_size
    
    with get_db_connection() as conn:
        # 获取总数
        total = conn.execute(
            "SELECT COUNT(*) FROM publishing_tasks"
        ).fetchone()[0]
        
        # 获取分页数据
        tasks = conn.execute(
            """
            SELECT * FROM publishing_tasks 
            ORDER BY created_at DESC 
            LIMIT ? OFFSET ?
            """,
            (page_size, offset)
        ).fetchall()
        
        return {
            "tasks": [dict(task) for task in tasks],
            "total": total,
            "page": page,
            "page_size": page_size,
            "total_pages": (total + page_size - 1) // page_size
        }
```

### 3. 异步编程

```python
import asyncio
import aiohttp
from typing import List, Dict, Any

class AsyncTwitterService:
    """异步Twitter服务"""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def post_tweet(self, content: str) -> Dict[str, Any]:
        """异步发布推文"""
        async with self.session.post(
            "https://api.twitter.com/2/tweets",
            json={"text": content},
            headers={"Authorization": f"Bearer {self.api_key}"}
        ) as response:
            return await response.json()
    
    async def batch_publish(
        self, 
        contents: List[str],
        delay: float = 1.0
    ) -> List[Dict[str, Any]]:
        """批量发布推文"""
        results = []
        
        for content in contents:
            try:
                result = await self.post_tweet(content)
                results.append(result)
                await asyncio.sleep(delay)  # 避免频率限制
            except Exception as e:
                results.append({"error": str(e)})
        
        return results

# 使用示例
async def main():
    contents = ["推文1", "推文2", "推文3"]
    
    async with AsyncTwitterService("your_api_key") as service:
        results = await service.batch_publish(contents)
        
    for i, result in enumerate(results):
        if "error" in result:
            print(f"推文 {i+1} 发布失败: {result['error']}")
        else:
            print(f"推文 {i+1} 发布成功: {result['data']['id']}")

# 运行
if __name__ == "__main__":
    asyncio.run(main())
```

## 调试技巧

### 1. 日志调试

```python
import logging
from app.utils.logger import get_logger

# 启用详细日志
logging.basicConfig(level=logging.DEBUG)
logger = get_logger(__name__)

def debug_function(data: Dict[str, Any]) -> None:
    """调试函数"""
    logger.debug(f"函数输入: {data}")
    
    try:
        # 处理逻辑
        result = process_data(data)
        logger.debug(f"处理结果: {result}")
        
    except Exception as e:
        logger.exception(f"处理失败: {e}")
        logger.debug(f"错误上下文: {locals()}")
        raise
```

### 2. 性能分析

```python
import cProfile
import pstats
from functools import wraps
import time

def profile_function(func):
    """函数性能分析装饰器"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        pr = cProfile.Profile()
        pr.enable()
        
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        
        pr.disable()
        
        # 输出性能统计
        stats = pstats.Stats(pr)
        stats.sort_stats('cumulative')
        stats.print_stats(10)  # 显示前10个最耗时的函数
        
        print(f"函数 {func.__name__} 执行时间: {end_time - start_time:.4f}秒")
        
        return result
    return wrapper

@profile_function
def slow_function():
    # 模拟耗时操作
    time.sleep(1)
    return "完成"
```

### 3. 内存调试

```python
import tracemalloc
import psutil
import os

def monitor_memory():
    """监控内存使用"""
    process = psutil.Process(os.getpid())
    memory_info = process.memory_info()
    
    print(f"RSS内存: {memory_info.rss / 1024 / 1024:.2f} MB")
    print(f"VMS内存: {memory_info.vms / 1024 / 1024:.2f} MB")
    
    # 跟踪内存分配
    if tracemalloc.is_tracing():
        current, peak = tracemalloc.get_traced_memory()
        print(f"当前内存: {current / 1024 / 1024:.2f} MB")
        print(f"峰值内存: {peak / 1024 / 1024:.2f} MB")

# 启用内存跟踪
tracemalloc.start()

# 在关键点监控内存
monitor_memory()
```

---

**下一步**: 查看 [部署指南](06_部署指南.md) 了解生产环境部署方法。