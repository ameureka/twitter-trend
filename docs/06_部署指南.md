# 部署指南

## 部署概述

Twitter自动发布系统支持多种部署方式，从本地开发到生产环境，提供灵活的部署选项以满足不同场景需求。

## 部署架构选择

### 1. 单机部署
- **适用场景**: 个人使用、小团队、测试环境
- **资源要求**: 2GB RAM, 1 CPU核心, 10GB存储
- **优势**: 简单易用、成本低、维护简单
- **劣势**: 单点故障、扩展性有限

### 2. 容器化部署
- **适用场景**: 中小型团队、开发测试环境
- **资源要求**: 4GB RAM, 2 CPU核心, 20GB存储
- **优势**: 环境一致性、易于扩展、版本管理
- **劣势**: 需要Docker知识、资源开销

### 3. 云端部署
- **适用场景**: 企业级应用、高可用需求
- **资源要求**: 根据负载动态调整
- **优势**: 高可用、自动扩展、专业运维
- **劣势**: 成本较高、复杂度高

## Docker部署

### 1. 快速启动

#### 使用Docker Compose (推荐)

```bash
# 克隆项目
git clone https://github.com/your-org/twitter-auto-publisher.git
cd twitter-auto-publisher

# 配置环境变量
cp .env.example .env
vim .env  # 编辑配置

# 启动服务
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看日志
docker-compose logs -f
```

#### Docker Compose 配置

**docker-compose.yml**:

```yaml
version: '3.8'

services:
  twitter-publisher:
    build:
      context: .
      dockerfile: docker/Dockerfile
    container_name: twitter-publisher
    restart: unless-stopped
    ports:
      - "8080:8080"  # API服务端口
      - "8080:8080"  # Web界面端口
    environment:
      - APP_ENV=production
      - DATABASE_URL=sqlite:///data/twitter_publisher.db
    env_file:
      - .env
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
      - ./config:/app/config
      - ./projects:/app/projects  # 项目数据目录
    networks:
      - twitter-net
    healthcheck:
      test: ["CMD", "python", "-m", "app.cli", "health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # 可选: 数据库服务 (如果使用PostgreSQL)
  postgres:
    image: postgres:15-alpine
    container_name: twitter-publisher-db
    restart: unless-stopped
    environment:
      POSTGRES_DB: twitter_publisher
      POSTGRES_USER: twitter_user
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./docker/init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - twitter-net
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U twitter_user -d twitter_publisher"]
      interval: 10s
      timeout: 5s
      retries: 5

  # 可选: Redis缓存
  redis:
    image: redis:7-alpine
    container_name: twitter-publisher-redis
    restart: unless-stopped
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    networks:
      - twitter-net
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3

  # 可选: 监控服务
  prometheus:
    image: prom/prometheus:latest
    container_name: twitter-publisher-prometheus
    restart: unless-stopped
    ports:
      - "9090:9090"
    volumes:
      - ./docker/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    networks:
      - twitter-net

  grafana:
    image: grafana/grafana:latest
    container_name: twitter-publisher-grafana
    restart: unless-stopped
    ports:
      - "8080:8080"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
      - ./docker/grafana/dashboards:/etc/grafana/provisioning/dashboards
      - ./docker/grafana/datasources:/etc/grafana/provisioning/datasources
    networks:
      - twitter-net

volumes:
  postgres_data:
  redis_data:
  prometheus_data:
  grafana_data:

networks:
  twitter-net:
    driver: bridge
```

### 2. Dockerfile

**docker/Dockerfile**:

```dockerfile
# 多阶段构建
FROM python:3.11-slim as builder

# 设置工作目录
WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    git \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt requirements-prod.txt ./

# 安装Python依赖
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements-prod.txt

# 生产阶段
FROM python:3.11-slim as production

# 创建非root用户
RUN groupadd -r appuser && useradd -r -g appuser appuser

# 设置工作目录
WORKDIR /app

# 安装运行时依赖
RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

# 从构建阶段复制Python包
COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=builder /usr/local/bin /usr/local/bin

# 复制应用代码
COPY app/ ./app/
COPY config/ ./config/
COPY scripts/ ./scripts/
COPY docker/entrypoint.sh ./

# 创建必要目录
RUN mkdir -p data logs projects && \
    chown -R appuser:appuser /app

# 设置执行权限
RUN chmod +x entrypoint.sh

# 切换到非root用户
USER appuser

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
    CMD python -m app.cli health || exit 1

# 暴露端口
EXPOSE 8080

# 设置环境变量
ENV PYTHONPATH=/app
ENV APP_ENV=production

# 启动脚本
ENTRYPOINT ["./entrypoint.sh"]
CMD ["api"]
```

### 3. 启动脚本

**docker/entrypoint.sh**:

```bash
#!/bin/bash
set -e

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${GREEN}🚀 启动 Twitter Auto Publisher...${NC}"

# 等待数据库就绪 (如果使用外部数据库)
if [ "$DATABASE_URL" != "sqlite:///data/twitter_publisher.db" ]; then
    echo -e "${YELLOW}⏳ 等待数据库就绪...${NC}"
    python -c "
import time
import sys
from app.database.db_manager import DatabaseManager

for i in range(30):
    try:
        db = DatabaseManager()
        db.check_health()
        print('数据库连接成功')
        break
    except Exception as e:
        print(f'等待数据库... ({i+1}/30): {e}')
        time.sleep(2)
else:
    print('数据库连接超时')
    sys.exit(1)
"
fi

# 初始化数据库
echo -e "${YELLOW}📊 初始化数据库...${NC}"
python -m app.cli db init

# 运行数据库迁移
echo -e "${YELLOW}🔄 运行数据库迁移...${NC}"
python -m app.cli db migrate

# 验证系统配置
echo -e "${YELLOW}✅ 验证系统配置...${NC}"
python -m app.cli validate

# 根据参数启动不同服务
case "$1" in
    "api")
        echo -e "${GREEN}🌐 启动API服务...${NC}"
        exec python -m app.api.main
        ;;
    "scheduler")
        echo -e "${GREEN}⏰ 启动调度服务...${NC}"
        exec python -m app.cli scheduler start
        ;;
    "worker")
        echo -e "${GREEN}👷 启动工作进程...${NC}"
        exec python -m app.cli worker start
        ;;
    "web")
        echo -e "${GREEN}🖥️ 启动Web界面...${NC}"
        exec python -m app.web.main
        ;;
    "all")
        echo -e "${GREEN}🚀 启动所有服务...${NC}"
        # 使用supervisor或类似工具管理多个进程
        exec python -m app.main
        ;;
    *)
        echo -e "${RED}❌ 未知服务类型: $1${NC}"
        echo "可用选项: api, scheduler, worker, web, all"
        exit 1
        ;;
esac
```

### 4. 开发环境配置

**docker-compose.dev.yml**:

```yaml
version: '3.8'

services:
  twitter-publisher-dev:
    build:
      context: .
      dockerfile: docker/Dockerfile.dev
    container_name: twitter-publisher-dev
    ports:
      - "8080:8080"
      - "8080:8080"
      - "5678:5678"  # 调试端口
    environment:
      - APP_ENV=development
      - APP_DEBUG=true
    env_file:
      - .env.dev
    volumes:
      - .:/app  # 挂载源代码用于开发
      - /app/venv  # 排除虚拟环境
    networks:
      - twitter-net
    command: >
      bash -c "pip install -e . &&
               python -m app.cli db init &&
               python -m debugpy --listen 0.0.0.0:5678 --wait-for-client -m app.api.main"

networks:
  twitter-net:
    driver: bridge
```

## 本地部署

### 1. 系统要求

- **操作系统**: Ubuntu 20.04+, CentOS 8+, macOS 10.15+, Windows 10+
- **Python**: 3.8+
- **内存**: 最低 2GB，推荐 4GB+
- **存储**: 最低 5GB 可用空间
- **网络**: 稳定的互联网连接

### 2. 安装步骤

#### Ubuntu/Debian

```bash
# 更新系统
sudo apt update && sudo apt upgrade -y

# 安装系统依赖
sudo apt install -y python3 python3-pip python3-venv git curl wget

# 克隆项目
git clone https://github.com/your-org/twitter-auto-publisher.git
cd twitter-auto-publisher

# 创建虚拟环境
python3 -m venv venv
source venv/bin/activate

# 安装依赖
pip install --upgrade pip
pip install -r requirements.txt

# 配置环境
cp .env.example .env
vim .env

# 初始化系统
python -m app.cli setup

# 启动服务
python -m app.main
```

#### CentOS/RHEL

```bash
# 安装EPEL仓库
sudo yum install -y epel-release

# 安装系统依赖
sudo yum install -y python3 python3-pip git curl wget

# 其余步骤同Ubuntu
```

#### macOS

```bash
# 安装Homebrew (如果未安装)
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# 安装Python
brew install python@3.11

# 其余步骤同Ubuntu
```

#### Windows

```powershell
# 使用Chocolatey安装Python
choco install python git

# 或者从官网下载安装
# https://www.python.org/downloads/

# 克隆项目
git clone https://github.com/your-org/twitter-auto-publisher.git
cd twitter-auto-publisher

# 创建虚拟环境
python -m venv venv
venv\Scripts\activate

# 安装依赖
pip install --upgrade pip
pip install -r requirements.txt

# 配置和启动
copy .env.example .env
notepad .env
python -m app.cli setup
python -m app.main
```

### 3. 系统服务配置

#### Systemd服务 (Linux)

**创建服务文件** `/etc/systemd/system/twitter-publisher.service`:

```ini
[Unit]
Description=Twitter Auto Publisher
After=network.target
Wants=network.target

[Service]
Type=simple
User=twitter
Group=twitter
WorkingDirectory=/opt/twitter-publisher
Environment=PATH=/opt/twitter-publisher/venv/bin
EnvironmentFile=/opt/twitter-publisher/.env
ExecStart=/opt/twitter-publisher/venv/bin/python -m app.main
ExecReload=/bin/kill -HUP $MAINPID
Restart=always
RestartSec=10
KillMode=mixed
TimeoutStopSec=30

# 安全设置
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/opt/twitter-publisher/data /opt/twitter-publisher/logs

# 资源限制
LimitNOFILE=65536
LimitNPROC=4096

[Install]
WantedBy=multi-user.target
```

**启用和管理服务**:

```bash
# 重载systemd配置
sudo systemctl daemon-reload

# 启用服务
sudo systemctl enable twitter-publisher

# 启动服务
sudo systemctl start twitter-publisher

# 查看状态
sudo systemctl status twitter-publisher

# 查看日志
sudo journalctl -u twitter-publisher -f

# 重启服务
sudo systemctl restart twitter-publisher

# 停止服务
sudo systemctl stop twitter-publisher
```

## 云端部署

### 1. AWS部署

#### EC2实例部署

```bash
# 创建EC2实例
aws ec2 run-instances \
    --image-id ami-0c02fb55956c7d316 \
    --instance-type t3.medium \
    --key-name your-key-pair \
    --security-group-ids sg-xxxxxxxxx \
    --subnet-id subnet-xxxxxxxxx \
    --user-data file://scripts/aws-user-data.sh

# 用户数据脚本 (scripts/aws-user-data.sh)
#!/bin/bash
yum update -y
yum install -y python3 python3-pip git docker

# 启动Docker
systemctl start docker
systemctl enable docker
usermod -a -G docker ec2-user

# 安装Docker Compose
curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose

# 克隆和部署应用
cd /opt
git clone https://github.com/your-org/twitter-auto-publisher.git
cd twitter-auto-publisher
cp .env.example .env

# 配置环境变量 (从AWS Secrets Manager获取)
aws secretsmanager get-secret-value --secret-id twitter-publisher-secrets --query SecretString --output text > .env

# 启动服务
docker-compose up -d
```

#### ECS部署

**任务定义** (aws/task-definition.json):

```json
{
  "family": "twitter-publisher",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "512",
  "memory": "1024",
  "executionRoleArn": "arn:aws:iam::account:role/ecsTaskExecutionRole",
  "taskRoleArn": "arn:aws:iam::account:role/ecsTaskRole",
  "containerDefinitions": [
    {
      "name": "twitter-publisher",
      "image": "your-account.dkr.ecr.region.amazonaws.com/twitter-publisher:latest",
      "portMappings": [
        {
          "containerPort": 8080,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {
          "name": "APP_ENV",
          "value": "production"
        }
      ],
      "secrets": [
        {
          "name": "TWITTER_API_KEY",
          "valueFrom": "arn:aws:secretsmanager:region:account:secret:twitter-api-key"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/twitter-publisher",
          "awslogs-region": "us-west-2",
          "awslogs-stream-prefix": "ecs"
        }
      },
      "healthCheck": {
        "command": [
          "CMD-SHELL",
          "python -m app.cli health || exit 1"
        ],
        "interval": 30,
        "timeout": 5,
        "retries": 3,
        "startPeriod": 60
      }
    }
  ]
}
```

### 2. Google Cloud Platform部署

#### Cloud Run部署

```bash
# 构建和推送镜像
gcloud builds submit --tag gcr.io/PROJECT_ID/twitter-publisher

# 部署到Cloud Run
gcloud run deploy twitter-publisher \
    --image gcr.io/PROJECT_ID/twitter-publisher \
    --platform managed \
    --region us-central1 \
    --allow-unauthenticated \
    --memory 1Gi \
    --cpu 1 \
    --max-instances 10 \
    --set-env-vars APP_ENV=production \
    --set-secrets TWITTER_API_KEY=twitter-api-key:latest
```

#### GKE部署

**Kubernetes配置** (k8s/deployment.yaml):

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: twitter-publisher
  labels:
    app: twitter-publisher
spec:
  replicas: 3
  selector:
    matchLabels:
      app: twitter-publisher
  template:
    metadata:
      labels:
        app: twitter-publisher
    spec:
      containers:
      - name: twitter-publisher
        image: gcr.io/PROJECT_ID/twitter-publisher:latest
        ports:
        - containerPort: 8080
        env:
        - name: APP_ENV
          value: "production"
        envFrom:
        - secretRef:
            name: twitter-publisher-secrets
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: twitter-publisher-service
spec:
  selector:
    app: twitter-publisher
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: LoadBalancer
```

### 3. Azure部署

#### Container Instances

```bash
# 创建资源组
az group create --name twitter-publisher-rg --location eastus

# 创建容器实例
az container create \
    --resource-group twitter-publisher-rg \
    --name twitter-publisher \
    --image your-registry.azurecr.io/twitter-publisher:latest \
    --cpu 1 \
    --memory 2 \
    --ports 8080 \
    --environment-variables APP_ENV=production \
    --secure-environment-variables TWITTER_API_KEY=$TWITTER_API_KEY \
    --restart-policy Always
```

## 负载均衡和高可用

### 1. Nginx负载均衡

**nginx.conf**:

```nginx
upstream twitter_publisher {
    least_conn;
    server 127.0.0.1:8001 weight=1 max_fails=3 fail_timeout=30s;
    server 127.0.0.1:8002 weight=1 max_fails=3 fail_timeout=30s;
    server 127.0.0.1:8003 weight=1 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;
    server_name your-domain.com;
    
    # 重定向到HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-domain.com;
    
    # SSL配置
    ssl_certificate /etc/ssl/certs/your-domain.crt;
    ssl_certificate_key /etc/ssl/private/your-domain.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    
    # 安全头
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload";
    
    # API代理
    location /api/ {
        proxy_pass http://twitter_publisher;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # 超时设置
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;
        
        # 缓冲设置
        proxy_buffering on;
        proxy_buffer_size 4k;
        proxy_buffers 8 4k;
    }
    
    # 静态文件
    location /static/ {
        alias /opt/twitter-publisher/app/web/static/;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
    
    # 健康检查
    location /health {
        proxy_pass http://twitter_publisher/health;
        access_log off;
    }
    
    # 限流
    location /api/auth/ {
        limit_req zone=auth burst=5 nodelay;
        proxy_pass http://twitter_publisher;
    }
}

# 限流配置
http {
    limit_req_zone $binary_remote_addr zone=auth:10m rate=1r/s;
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
}
```

### 2. HAProxy配置

**haproxy.cfg**:

```
global
    daemon
    maxconn 4096
    log stdout local0
    
defaults
    mode http
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms
    option httplog
    option dontlognull
    option redispatch
    retries 3
    
frontend twitter_publisher_frontend
    bind *:80
    bind *:443 ssl crt /etc/ssl/certs/your-domain.pem
    redirect scheme https if !{ ssl_fc }
    
    # ACL规则
    acl is_api path_beg /api/
    acl is_health path /health
    
    # 路由规则
    use_backend twitter_publisher_api if is_api
    use_backend twitter_publisher_health if is_health
    default_backend twitter_publisher_web
    
backend twitter_publisher_api
    balance roundrobin
    option httpchk GET /health
    server api1 127.0.0.1:8001 check
    server api2 127.0.0.1:8002 check
    server api3 127.0.0.1:8003 check
    
backend twitter_publisher_web
    balance roundrobin
    option httpchk GET /health
    server web1 127.0.0.1:8081 check
    server web2 127.0.0.1:8082 check
    
backend twitter_publisher_health
    balance roundrobin
    server health1 127.0.0.1:8001 check
    server health2 127.0.0.1:8002 check
    server health3 127.0.0.1:8003 check
```

## 监控和日志

### 1. 应用监控

#### Prometheus配置

**docker/prometheus.yml**:

```yaml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

scrape_configs:
  - job_name: 'twitter-publisher'
    static_configs:
      - targets: ['twitter-publisher:8080']
    metrics_path: '/metrics'
    scrape_interval: 10s
    
  - job_name: 'node-exporter'
    static_configs:
      - targets: ['node-exporter:9100']
      
  - job_name: 'postgres-exporter'
    static_configs:
      - targets: ['postgres-exporter:9187']
```

#### 告警规则

**docker/alert_rules.yml**:

```yaml
groups:
  - name: twitter_publisher_alerts
    rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value }} errors per second"
          
      - alert: HighMemoryUsage
        expr: process_resident_memory_bytes / 1024 / 1024 > 500
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "High memory usage"
          description: "Memory usage is {{ $value }}MB"
          
      - alert: ServiceDown
        expr: up{job="twitter-publisher"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Service is down"
          description: "Twitter Publisher service is not responding"
```

### 2. 日志管理

#### ELK Stack配置

**docker/elasticsearch.yml**:

```yaml
version: '3.8'

services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.8.0
    container_name: elasticsearch
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
      - xpack.security.enabled=false
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
    ports:
      - "9200:9200"
    networks:
      - elk
      
  logstash:
    image: docker.elastic.co/logstash/logstash:8.8.0
    container_name: logstash
    volumes:
      - ./logstash/pipeline:/usr/share/logstash/pipeline
      - ./logs:/logs
    ports:
      - "5044:5044"
    networks:
      - elk
    depends_on:
      - elasticsearch
      
  kibana:
    image: docker.elastic.co/kibana/kibana:8.8.0
    container_name: kibana
    ports:
      - "5601:5601"
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
    networks:
      - elk
    depends_on:
      - elasticsearch

volumes:
  elasticsearch_data:

networks:
  elk:
    driver: bridge
```

## 安全配置

### 1. 防火墙配置

```bash
# UFW (Ubuntu)
sudo ufw enable
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow ssh
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp

# 仅允许特定IP访问管理端口
sudo ufw allow from 192.168.1.0/24 to any port 8080

# iptables (CentOS/RHEL)
sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT
sudo iptables -A INPUT -j DROP
sudo iptables-save > /etc/iptables/rules.v4
```

### 2. SSL/TLS配置

```bash
# 使用Let's Encrypt获取免费SSL证书
sudo apt install certbot python3-certbot-nginx

# 获取证书
sudo certbot --nginx -d your-domain.com

# 自动续期
sudo crontab -e
# 添加: 0 12 * * * /usr/bin/certbot renew --quiet
```

### 3. 安全加固

```bash
# 禁用root登录
sudo sed -i 's/PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config

# 更改SSH端口
sudo sed -i 's/#Port 22/Port 2222/' /etc/ssh/sshd_config

# 禁用密码登录，仅使用密钥
sudo sed -i 's/#PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config

# 重启SSH服务
sudo systemctl restart sshd

# 安装fail2ban
sudo apt install fail2ban
sudo systemctl enable fail2ban
sudo systemctl start fail2ban
```

## 备份和恢复

### 1. 数据备份

**备份脚本** (scripts/backup.sh):

```bash
#!/bin/bash

BACKUP_DIR="/opt/backups/twitter-publisher"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_NAME="twitter_publisher_backup_$DATE"

# 创建备份目录
mkdir -p $BACKUP_DIR

# 备份数据库
echo "备份数据库..."
sqlite3 /opt/twitter-publisher/data/twitter_publisher.db ".backup $BACKUP_DIR/${BACKUP_NAME}.db"

# 备份配置文件
echo "备份配置文件..."
tar -czf $BACKUP_DIR/${BACKUP_NAME}_config.tar.gz -C /opt/twitter-publisher config/ .env

# 备份项目数据
echo "备份项目数据..."
tar -czf $BACKUP_DIR/${BACKUP_NAME}_projects.tar.gz -C /opt/twitter-publisher projects/

# 备份日志
echo "备份日志..."
tar -czf $BACKUP_DIR/${BACKUP_NAME}_logs.tar.gz -C /opt/twitter-publisher logs/

# 清理旧备份 (保留30天)
find $BACKUP_DIR -name "twitter_publisher_backup_*" -mtime +30 -delete

echo "备份完成: $BACKUP_NAME"
```

### 2. 自动备份

```bash
# 添加到crontab
crontab -e

# 每天凌晨2点备份
0 2 * * * /opt/twitter-publisher/scripts/backup.sh

# 每周日凌晨3点备份到云存储
0 3 * * 0 /opt/twitter-publisher/scripts/backup_to_cloud.sh
```

### 3. 恢复脚本

**恢复脚本** (scripts/restore.sh):

```bash
#!/bin/bash

if [ $# -ne 1 ]; then
    echo "用法: $0 <backup_name>"
    echo "可用备份:"
    ls /opt/backups/twitter-publisher/
    exit 1
fi

BACKUP_NAME=$1
BACKUP_DIR="/opt/backups/twitter-publisher"
APP_DIR="/opt/twitter-publisher"

# 停止服务
echo "停止服务..."
sudo systemctl stop twitter-publisher

# 恢复数据库
echo "恢复数据库..."
cp $APP_DIR/data/twitter_publisher.db $APP_DIR/data/twitter_publisher.db.backup
sqlite3 $APP_DIR/data/twitter_publisher.db ".restore $BACKUP_DIR/${BACKUP_NAME}.db"

# 恢复配置
echo "恢复配置..."
tar -xzf $BACKUP_DIR/${BACKUP_NAME}_config.tar.gz -C $APP_DIR/

# 恢复项目数据
echo "恢复项目数据..."
tar -xzf $BACKUP_DIR/${BACKUP_NAME}_projects.tar.gz -C $APP_DIR/

# 设置权限
chown -R twitter:twitter $APP_DIR

# 启动服务
echo "启动服务..."
sudo systemctl start twitter-publisher

# 验证恢复
echo "验证恢复..."
sleep 10
python -m app.cli health

echo "恢复完成"
```

---

**下一步**: 查看 [故障排除指南](07_故障排除.md) 了解常见问题的解决方法。