{
  "status": "FAILED",
  "errors": [
    "记忆系统验证失败：太多文件缺失或无效"
  ],
  "completedPhases": [],
  "failedPhase": 1,
  "results": [
    [
      "legacy-code-analyzer",
      {
        "success": true,
        "duration": 172058,
        "output": {
          "stdout": "## 🔥 立即可执行的修复代码\n\n### 1️⃣ **紧急日志修复脚本** (fix_logs_immediately.py)\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\n紧急日志修复脚本 - 立即执行防止磁盘满\n保存为: fix_logs_immediately.py\n执行: python fix_logs_immediately.py\n\"\"\"\n\nimport os\nimport shutil\nfrom pathlib import Path\nfrom datetime import datetime\n\ndef backup_and_rotate_logs():\n    \"\"\"备份现有日志并启用轮转\"\"\"\n    log_dir = Path(__file__).parent / 'logs'\n    archive_dir = log_dir / 'archive'\n    archive_dir.mkdir(exist_ok=True)\n    \n    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n    \n    # 备份大日志文件\n    for log_file in log_dir.glob('*.log'):\n        if log_file.stat().st_size > 1024*1024:  # 大于1MB\n            backup_path = archive_dir / f\"{log_file.stem}_{timestamp}{log_file.suffix}\"\n            print(f\"备份大文件: {log_file.name} ({log_file.stat().st_size//1024}KB)\")\n            shutil.move(str(log_file), str(backup_path))\n            # 创建新的空日志文件\n            log_file.touch()\n    \n    print(f\"✅ 日志备份完成\")\n\ndef update_logger_with_rotation():\n    \"\"\"更新logger.py添加轮转功能\"\"\"\n    logger_file = Path(__file__).parent / 'app' / 'utils' / 'logger.py'\n    \n    # 在第8行后插入\n    insert_code = \"\"\"from logging.handlers import RotatingFileHandler\"\"\"\n    \n    # 替换第38行的FileHandler\n    replace_from = \"file_handler = logging.FileHandler(log_path, encoding='utf-8')\"\n    replace_to = \"\"\"file_handler = RotatingFileHandler(\n        log_path, \n        maxBytes=10*1024*1024,  # 10MB\n        backupCount=5,\n        encoding='utf-8'\n    )\"\"\"\n    \n    if logger_file.exists():\n        content = logger_file.read_text(encoding='utf-8')\n        # 添加import\n        if 'RotatingFileHandler' not in content:\n            lines = content.split('\\n')\n            lines.insert(5, insert_code)\n            content = '\\n'.join(lines)\n        # 替换FileHandler\n        content = content.replace(replace_from, replace_to)\n        logger_file.write_text(content, encoding='utf-8')\n        print(\"✅ 已更新logger.py，启用日志轮转\")\n\nif __name__ == '__main__':\n    print(\"🚀 执行紧急日志修复...\")\n    backup_and_rotate_logs()\n    update_logger_with_rotation()\n    print(\"✅ 完成! 重启系统生效\")\n```\n\n### 2️⃣ **API限流智能修复** (fix_api_rate_limit.py)\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\n修复API限流问题 - 智能请求管理\n保存为: fix_api_rate_limit.py\n执行: python fix_api_rate_limit.py\n\"\"\"\n\nimport time\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\n\ndef patch_publisher():\n    \"\"\"修补publisher.py添加智能延迟\"\"\"\n    publisher_file = Path(__file__).parent / 'app' / 'core' / 'publisher.py'\n    \n    # 在post_tweet_with_video函数开始处添加\n    smart_delay_code = \"\"\"\n        # 智能API限流延迟\n        import random\n        base_delay = 3  # 基础延迟3秒\n        jitter = random.uniform(0, 2)  # 添加0-2秒随机抖动\n        smart_delay = base_delay + jitter\n        \n        # 检查上次请求时间(存储在类属性中)\n        if hasattr(self, '_last_request_time'):\n            elapsed = time.time() - self._last_request_time\n            if elapsed < smart_delay:\n                wait_time = smart_delay - elapsed\n                logger.info(f\"[RATE_LIMIT] 智能延迟 {wait_time:.1f} 秒避免限流\")\n                time.sleep(wait_time)\n        \n        self._last_request_time = time.time()\n\"\"\"\n    \n    if publisher_file.exists():\n        content = publisher_file.read_text(encoding='utf-8')\n        \n        # 在函数开始处插入智能延迟\n        insertion_point = 'def post_tweet_with_video(self, text: str, video_path: str)'\n        if insertion_point in content and '[RATE_LIMIT]' not in content:\n            lines = content.split('\\n')\n            for i, line in enumerate(lines):\n                if insertion_point in line:\n                    # 找到函数定义后的第一行代码位置\n                    j = i + 1\n                    while j < len(lines) and (lines[j].strip().startswith('\"\"\"') or not lines[j].strip()):\n                        j += 1\n                    # 插入智能延迟代码\n                    lines.insert(j, smart_delay_code)\n                    break\n            \n            content = '\\n'.join(lines)\n            publisher_file.write_text(content, encoding='utf-8')\n            print(\"✅ 已修补publisher.py，添加智能API延迟\")\n    \n    # 同时更新配置\n    update_config_for_rate_limit()\n\ndef update_config_for_rate_limit():\n    \"\"\"更新配置文件优化限流参数\"\"\"\n    config_file = Path(__file__).parent / 'config' / 'enhanced_config.yaml'\n    \n    if config_file.exists():\n        content = config_file.read_text(encoding='utf-8')\n        \n        # 更新调度参数\n        updates = [\n            ('batch_size: 1', 'batch_size: 1  # 保持单个发布避免限流'),\n            ('interval_hours: 4', 'interval_hours: 1  # 每小时检查一次'),\n            ('min_publish_interval: 14400', 'min_publish_interval: 180  # 最小3分钟间隔'),\n        ]\n        \n        for old, new in updates:\n            if old in content:\n                content = content.replace(old, new)\n        \n        config_file.write_text(content, encoding='utf-8')\n        print(\"✅ 已优化配置文件限流参数\")\n\nif __name__ == '__main__':\n    print(\"🔧 修复API限流问题...\")\n    patch_publisher()\n    print(\"✅ 完成! 重启系统生效\")\n    print(\"\\n建议:\")\n    print(\"1. 每次发布间隔至少3分钟\")\n    print(\"2. 使用batch_size=1避免并发\")\n    print(\"3. 监控logs/main.log查看效果\")\n```\n\n### 3️⃣ **修复卡死任务** (fix_stuck_tasks.py)\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\n修复卡死任务 - 清理running状态\n保存为: fix_stuck_tasks.py\n执行: python fix_stuck_tasks.py\n\"\"\"\n\nimport sqlite3\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\n\ndef fix_stuck_tasks():\n    \"\"\"修复所有卡死的任务\"\"\"\n    db_path = Path(__file__).parent / 'data' / 'enhanced_twitter_automation.db'\n    \n    if not db_path.exists():\n        # 尝试其他数据库\n        db_path = Path(__file__).parent / 'data' / 'twitter_publisher.db'\n    \n    if not db_path.exists():\n        print(\"❌ 找不到数据库文件\")\n        return\n    \n    conn = sqlite3.connect(str(db_path))\n    cursor = conn.cursor()\n    \n    # 查找卡死的任务\n    stuck_threshold = datetime.now() - timedelta(hours=2)\n    stuck_time = stuck_threshold.strftime('%Y-%m-%d %H:%M:%S')\n    \n    # 查询卡死任务\n    cursor.execute(\"\"\"\n        SELECT id, status, updated_at \n        FROM publishing_tasks \n        WHERE status = 'running' \n        AND updated_at < ",
          "stderr": "",
          "exitCode": 0
        },
        "timestamp": "2025-08-16T20:59:48.762Z"
      }
    ]
  ],
  "timestamp": "2025-08-16T20:59:48.763Z",
  "diagnostics": {
    "platform": "darwin",
    "projectType": {
      "type": "Node.js",
      "indicator": "package.json"
    },
    "discoveredConfigs": 3,
    "nodeVersion": "v22.14.0"
  }
}